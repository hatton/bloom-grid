<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Table Renderer Demo</title>
    <style>
        /* --- Page Layout --- */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            gap: 20px;
            padding: 20px;
            background-color: #f4f4f7;
            margin: 0;
        }
        .column {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h2 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        pre { background-color: #2d2d2d; color: #ccc; padding: 15px; border-radius: 6px; white-space: pre-wrap; word-wrap: break-word; }
        
        /* --- The Global CSS Renderer Engine --- */
        .grid {
            display: grid;
        }
        .grid > .cell {
            box-sizing: border-box; /* Crucial for correct border rendering */
            position: relative; /* Needed for z-index and negative margins */

            /* Apply borders using CSS variables with fallbacks */
            border-top: var(--border-top-width, 0) var(--border-top-style, none) var(--border-top-color, transparent);
            border-right: var(--border-right-width, 0) var(--border-right-style, none) var(--border-right-color, transparent);
            border-bottom: var(--border-bottom-width, 0) var(--border-bottom-style, none) var(--border-bottom-color, transparent);
            border-left: var(--border-left-width, 0) var(--border-left-style, none) var(--border-left-color, transparent);

            /* Use negative margins to collapse borders and allow overlaps */
            margin-top: calc(-1 * var(--border-top-width, 0px));
            margin-left: calc(-1 * var(--border-left-width, 0px));
            
            /* z-index controls which border wins in an overlap conflict */
            z-index: var(--cell-z-index, 1);

            /* Basic cell content styling */
            display: flex;
            align-items: flex-start;
        }
        .cell > [contenteditable] {
            width: 100%;
            min-height: 20px; /* Prevent contenteditable from collapsing */
        }
    </style>
</head>
<body>

    <div class="column">
        <h2>1. The "Model" HTML (Source of Truth)</h2>
        <p>This is the clean HTML with `data-*` attributes that the script reads. Notice the `style` attributes are empty.</p>
        <pre><code>&lt;div class="grid" 
     id="live-grid"
     data-column-widths="150px,grow,hug" 
     data-row-heights="100px,100px,grow"
     data-table-border='{"weight": 3, "color": "green", "type": "solid"}'
     data-default-border='{"weight": 1, "color": "#ccc", "type": "dashed"}'
     data-col-border-left='{"0": {"weight": 2, "color": "purple", "type": "dotted"}}'&gt;

    &lt;!-- Cell 1: Spans 2x2, inherits borders --&gt;
    &lt;div class="cell" data-col-span="2" data-row-span="2"&gt;
      &lt;div contenteditable="true"&gt;Spanning Cell (A)&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Cell 2: Covered by span --&gt;
    &lt;div class="cell" data-is-covered="true"&gt;&lt;/div&gt;

    &lt;!-- Cell 3: Has custom insets --&gt;
    &lt;div class="cell" data-insets='{"top": 20, "right": 10, "bottom": 20, "left": 10}'&gt;
      &lt;div contenteditable="true"&gt;Cell with Insets (B)&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- Cell 4 & 5: Covered by span --&gt;
    &lt;div class="cell" data-is-covered="true"&gt;&lt;/div&gt;
    &lt;div class="cell" data-is-covered="true"&gt;&lt;/div&gt;

    &lt;!-- Cell 6: Inherits all default styles --&gt;
    &lt;div class="cell"&gt;
      &lt;div contenteditable="true"&gt;Inherited Border (C)&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Cell 7: Overrides its top border --&gt;
    &lt;div class="cell" data-border-top='{"weight": 4, "color": "red", "type": "solid"}'&gt;
      &lt;div contenteditable="true"&gt;Top Border Override (D)&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Cell 8: Overrides its left border --&gt;
    &lt;div class="cell" data-border-left='{"weight": 4, "color": "blue", "type": "solid"}'&gt;
      &lt;div contenteditable="true"&gt;Left Border Override (E)&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Cell 9: Has a background fill --&gt;
    &lt;div class="cell" data-fill="#f0f8ff"&gt;
      &lt;div contenteditable="true"&gt;Cell with Fill (F)&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
    </div>

    <div class="column">
        <h2>2. The "Rendered View"</h2>
        <p>This is the live result of the script processing the model. Inspect the elements to see the generated inline styles.</p>

        <!-- The actual grid that our script will operate on -->
        <div class="grid" 
             id="live-grid"
             data-column-widths="150px,grow,hug" 
             data-row-heights="100px,100px,grow"
             data-table-border='{"weight": 3, "color": "green", "type": "solid"}'
             data-default-border='{"weight": 1, "color": "#ccc", "type": "dashed"}'
             data-col-border-left='{"0": {"weight": 2, "color": "purple", "type": "dotted"}}'>

            <!-- Cell 1: Spans 2x2, inherits borders -->
            <div class="cell" data-col-span="2" data-row-span="2">
              <div contenteditable="true">Spanning Cell (A)</div>
            </div>

            <!-- Cell 2: Covered by span -->
            <div class="cell" data-is-covered="true"></div>

            <!-- Cell 3: Has custom insets -->
            <div class="cell" data-insets='{"top": 20, "right": 10, "bottom": 20, "left": 10}'>
              <div contenteditable="true">Cell with Insets (B)</div>
            </div>
            
            <!-- Cell 4 & 5: Covered by span -->
            <div class="cell" data-is-covered="true"></div>
            <div class="cell" data-is-covered="true"></div>

            <!-- Cell 6: Inherits all default styles -->
            <div class="cell">
              <div contenteditable="true">Inherited Border (C)</div>
            </div>

            <!-- Cell 7: Overrides its top border -->
            <div class="cell" data-border-top='{"weight": 4, "color": "red", "type": "solid"}'>
              <div contenteditable="true">Top Border Override (D)</div>
            </div>

            <!-- Cell 8: Overrides its left border -->
            <div class="cell" data-border-left='{"weight": 4, "color": "blue", "type": "solid"}'>
              <div contenteditable="true">Left Border Override (E)</div>
            </div>

            <!-- Cell 9: Has a background fill -->
            <div class="cell" data-fill="#f0f8ff">
              <div contenteditable="true">Cell with Fill (F)</div>
            </div>
        </div>

    </div>

    <script>
        // --- The JavaScript Renderer ---

        document.addEventListener('DOMContentLoaded', () => {
            const gridElement = document.getElementById('live-grid');
            if (gridElement) {
                renderGrid(gridElement);
            }
        });

        /**
         * Parses a JSON string from a data attribute into a stroke object.
         * @param {string | undefined} jsonString The JSON string.
         * @returns {object | null} A structured stroke object or null.
         */
        function parseStroke(jsonString) {
            if (!jsonString) return null;
            try {
                const data = JSON.parse(jsonString);
                if (typeof data.weight === 'undefined' || typeof data.color === 'undefined') return null;
                return {
                    weight: `${data.weight || 0}px`,
                    style: data.type || 'solid',
                    color: data.color || 'transparent'
                };
            } catch {
                return null;
            }
        }

        /**
         * Main rendering function that reads data-* attributes and applies styles.
         * @param {HTMLElement} gridElement The .grid element to render.
         */
        function renderGrid(gridElement) {
            // --- 1. Render Grid Dimensions ---
            const colWidths = (gridElement.dataset.columnWidths || '').split(',');
            const rowHeights = (gridElement.dataset.rowHeights || '').split(',');

            const toCss = (dim) => {
                if (dim === 'grow') return 'minmax(60px, 1fr)';
                if (dim === 'hug') return 'max-content';
                return dim; // Pass through values with units like "150px"
            };

            gridElement.style.gridTemplateColumns = colWidths.map(toCss).join(' ');
            gridElement.style.gridTemplateRows = rowHeights.map(toCss).join(' ');

            // --- 2. Parse Border Policies from Grid ---
            const tableBorder = parseStroke(gridElement.dataset.tableBorder);
            const defaultBorder = parseStroke(gridElement.dataset.defaultBorder);
            const colLeftOverrides = JSON.parse(gridElement.dataset.colBorderLeft || '{}');
            // Add other row/col overrides here...

            // --- 3. Render Each Cell ---
            const cells = Array.from(gridElement.querySelectorAll(':scope > .cell'));
            const numCols = colWidths.length;

            cells.forEach((cell, index) => {
                const cellEl = cell;
                
                // Handle covered cells from spans
                if (cellEl.dataset.isCovered === 'true') {
                    cellEl.style.display = 'none';
                    return;
                }

                const rowIndex = Math.floor(index / numCols);
                const colIndex = index % numCols;

                // Spans
                cellEl.style.gridColumn = `span ${cellEl.dataset.colSpan || 1}`;
                cellEl.style.gridRow = `span ${cellEl.dataset.rowSpan || 1}`;

                // Insets (Padding)
                const insets = cellEl.dataset.insets ? JSON.parse(cellEl.dataset.insets) : null;
                if (insets) {
                    cellEl.style.padding = `${insets.top}px ${insets.right}px ${insets.bottom}px ${insets.left}px`;
                }

                // Fill (Background Color)
                cellEl.style.backgroundColor = cellEl.dataset.fill || 'transparent';

                // --- 4. Border Precedence Logic ---
                const isFirstRow = rowIndex === 0;
                const isLastRow = rowIndex === Math.ceil(cells.length / numCols) - 1;
                const isFirstCol = colIndex === 0;
                const isLastCol = colIndex === numCols - 1;

                const borders = { top: null, right: null, bottom: null, left: null };

                // Apply precedence for each of the 4 sides
                ['top', 'right', 'bottom', 'left'].forEach(side => {
                    const capSide = side.charAt(0).toUpperCase() + side.slice(1);
                    
                    // L1: Cell override
                    let border = parseStroke(cellEl.dataset['border' + capSide]);
                    if (border) {
                        borders[side] = border;
                        return;
                    }
                    
                    // L2: Row/Column override (only showing col-left for this demo)
                    if (side === 'left' && colLeftOverrides[colIndex]) {
                         border = parseStroke(JSON.stringify(colLeftOverrides[colIndex]));
                         if (border) {
                             borders[side] = border;
                             return;
                         }
                    }

                    // L3: Table Border
                    if ( (side === 'top' && isFirstRow) || (side === 'bottom' && isLastRow) ||
                         (side === 'left' && isFirstCol) || (side === 'right' && isLastCol) ) {
                        if (tableBorder) {
                            borders[side] = tableBorder;
                            return;
                        }
                    }

                    // L4: Table Default
                    borders[side] = defaultBorder;
                });
                
                // --- 5. Apply Final Border Variables ---
                cellEl.style.setProperty('--border-top-width', borders.top?.weight || '0px');
                cellEl.style.setProperty('--border-top-style', borders.top?.style || 'none');
                cellEl.style.setProperty('--border-top-color', borders.top?.color || 'transparent');

                cellEl.style.setProperty('--border-right-width', borders.right?.weight || '0px');
                cellEl.style.setProperty('--border-right-style', borders.right?.style || 'none');
                cellEl.style.setProperty('--border-right-color', borders.right?.color || 'transparent');

                cellEl.style.setProperty('--border-bottom-width', borders.bottom?.weight || '0px');
                cellEl.style.setProperty('--border-bottom-style', borders.bottom?.style || 'none');
                cellEl.style.setProperty('--border-bottom-color', borders.bottom?.color || 'transparent');

                cellEl.style.setProperty('--border-left-width', borders.left?.weight || '0px');
                cellEl.style.setProperty('--border-left-style', borders.left?.style || 'none');
                cellEl.style.setProperty('--border-left-color', borders.left?.color || 'transparent');
            });
        }
    </script>
</body>
</html>